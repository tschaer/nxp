// slave.nxc
// 19.01.2012 T Schaer
// Process Dictionaries with configurable number of Nodes

const string Master = MASTER;
unsigned int BadRequests, BadCommands, Timeouts, Cycles;

mutex mxPDI;
mutex mxPDO;

// Process Dictionary
NewDict(PDO, NOFCOMMPARTNERS);
NewDict(PDI, NOFCOMMPARTNERS);
// Comm() Process dictionary
NewDict(CommPDO, NOFCOMMPARTNERS);
NewDict(CommPDI, NOFCOMMPARTNERS);
// Program() Process Dicitonary
NewDict(ProgramPDO, NOFCOMMPARTNERS);
NewDict(ProgramPDI, NOFCOMMPARTNERS);

// Protocol timeouts
TimerObject ReqMsgFinishTimer;
TimerObject CmdMsgBeginTimer;
TimerObject CmdMsgFinishTimer;

void CommInit() {
  // Set up High Speed Port
  SetSensorType(IN_4, SENSOR_TYPE_HIGHSPEED);
  SetHSState(HS_INITIALISE);
  SetHSFlags(HS_UPDATE);  
  
  // start with empty input buffer
  SetHSInputBufferInPtr(0);
  SetHSInputBufferOutPtr(0);
  
  // make sure everything gets turned on okay
  Wait(5);
  
  // Set up the timers
  ReqMsgFinishTimer.Timeout = 1000;
  CmdMsgBeginTimer.Timeout = 1000;
  CmdMsgFinishTimer.Timeout = 1000;

}

int CommState = -1;

void Comm() {
  bool Done = false;
  unsigned char MsgLen, CommandMsgLen;
  string RequestMessage, ResponseMessage;  
  string CommandMessage, StatusMessage;
  TickTock CommTaskElapsed;
    
  while (Done == false) {
    switch(CommState) {
      case -3:
        // State -3: Exit state
        SetHSInputBufferInPtr(0);
        Cycles++;
        Done = true;
        Tock(CommTaskElapsed);
        TextOut(0, LCD_LINE7, "Elapsed : " + NumToStr(Elapsed(CommTaskElapsed)));
        CommState = -1;
        break;
      case -1:
        // State -1: Initialize
        Tick(CommTaskElapsed);
        resetAll(CommPDI);
        resetAll(CommPDO);
        // Get PDO
        Acquire(mxPDO);
        CommPDO = PDO;
        Release(mxPDO);
        StatusMessage = serialize_Json(Master, CommPDO);
        ResponseMessage = RespMessage(Master, StrLen(StatusMessage), 0);        
        CommState = 0;
        break;
      case 0:
        // State 0: wait for Request Message
        if (HSInputBufferInPtr() > 0) {
          StartTimer(ReqMsgFinishTimer);
          CommState = 1;
        } else {
          Wait(5);
        }
        break;
      case 1:
        // State 1: receive Request Message
        MsgLen = HSInputBufferInPtr();
        if (MsgLen >= REQMSGLEN+1) {
          GetHSInputBuffer(0, REQMSGLEN+1, RequestMessage);
          SetHSInputBufferInPtr(0);
          if (parse_Json(RequestMessage, "Request", CommPDI) == true) {
            CommandMsgLen = StrToNum(lookup("len", "Request", CommPDI));
            SendRS485String(ResponseMessage);
            CommState = 2;
          } else {
            TextOut(0, LCD_LINE8, "Bad Request");
            BadRequests++;
            CommState = -3;            
          }
        } else if (CheckTimer(ReqMsgFinishTimer) == true) {
          Timeouts++;
          TextOut(0, LCD_LINE8, "Timeout State 1");
          CommState = -3;
        }
        break;
      case 2:
        // State 2: send Response Message
        if (SendingDone()) {
          StartTimer(CmdMsgBeginTimer);
          CommState = 3;          
        }
        break;
      case 3:
        // State 3: Wait for Command Message
       if (HSInputBufferInPtr() > 0) {
        StartTimer(CmdMsgFinishTimer);
        CommState = 4;
       } else if (CheckTimer(CmdMsgBeginTimer) == true) {
        Timeouts++;
        TextOut(0, LCD_LINE8, "Timeout State 3");
        CommState = -3;
       } else {
        Wait(5);
       }
       break;
      case 4:
        // State 4: receive Command Message
        MsgLen = HSInputBufferInPtr();
        if (MsgLen >= CommandMsgLen + 1) {
          GetHSInputBuffer(0, MsgLen, CommandMessage);
          resetAll(CommPDI);
          if (parse_Json(CommandMessage, Master, CommPDI) == false) {
            BadCommands++;
            TextOut(0, LCD_LINE8, "Bad Command Msg");
          }
          SendRS485String(StatusMessage);
          CommState = 5;
        } else if (CheckTimer(CmdMsgFinishTimer) == true) {
          Timeouts++;
          TextOut(0, LCD_LINE8, "Timeout State 4");
          CommState = -3;
        }
        break;
      case 5:
        // State 5: send Status Message
        if(SendingDone()) {
          // Move here temporarily so that Status Message is sent sooner
          Acquire(mxPDI);
          resetAll(PDI);
          PDI = CommPDI;
          Release(mxPDI);
          CommState = -3;          
        }
        break;
      default:
        // you should never get here, but...
        TextOut(0, LCD_LINE8, "w00t! Error!       ");
        Wait(10000);
        CommState = -3;
    }
  }
}

// forward reference for Slave Application
void Program();

task tMain() {
  TickTock Main;
  
  MainTask_resetAll(PDO);
  
  while (true) {
    Tick(Main);
    
    // Input comm section
    MainTask_resetAll(ProgramPDI);
    Acquire(mxPDI);
    ProgramPDI = PDI;
    Release(mxPDI);
    
    Program();
    
    // Output comm section
    Acquire(mxPDO);
    MainTask_resetAll(PDO);
    PDO = ProgramPDO;
    Release(mxPDO);
    MainTask_resetAll(ProgramPDO);
    
    // cyclic execution
    Tock(Main);
    Wait(CYCLETIME-Elapsed(Main));
  }
}

task tComm() {
  CommTask_resetAll(PDI);

  while(true) {
    Comm();
  }
}

task main() {
  CommInit();
  Precedes(tMain, tComm);
}