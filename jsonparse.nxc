// jsonparse.nxc
// 09.12.2011 T Schaer
// Parse subset of JSON into a Dictionary object
// Add Array into grammar, exponents, insignificant whitespace
// almost RFC 4627 compliant

// Parser BNF:
// text = array | object
// array = [] | [elements]
// elements = value | value,elements
// object = {} | {members}
// members = pair | pair,members
// pair = string:value
// value = string | number | nestedobject | nestedarray | true | false | null | undefined
// nestedobject = {} | {anything}
// nestedarray = [] | [anything]
// string = "" | "chars"
// chars = anything that gets by ctypes::isalnum() or '_' or '-'
// number = integers | -integers | reals | -reals
// integers = one or more of digits 0-9
// reals = one or more of digits 0-9 followed by optional decimal dot followed
//         by zero or more digits 0-9 followed by e or E followed by optional
//         plus or minus followed by zero or more digits 0-9

string ParseBuffer, Node;
char Symbol;
unsigned int SymbolPtr;
unsigned int ArrayPtr;

// ----- Auxiliary functions

// Read another character from ParseBuffer
void updateSymbol(void) {
  Symbol = ParseBuffer[SymbolPtr];
  SymbolPtr++;
}
// Accumulate characters
void addSymbolTo(string &String) {
  String = String + FlattenVar(Symbol);
  updateSymbol();
}
// Eat white space chars
void eatWhitespace(void) {
  while (isspace(Symbol)) {
    updateSymbol();
  }
}


// ---- Parser functions

string parse_Chars(void) {
  string Chars = "";
  
  while (isalnum(Symbol) || Symbol == '_' || Symbol == '-') {
    addSymbolTo(Chars);
  }
  return Chars;
}

// Pick out complete quoted strings or return "undefined"
string parse_String(void) {
  string String = "";
  
    updateSymbol();
    String = parse_Chars();
    if (Symbol == '"') {
      updateSymbol();
    } else {
      String = "undefined";
    }
  return String;
}

// Recognize numbers
// integers or reals with positive exponents
string parse_Number(void) {
  string Number = "";
  
  if (Symbol == '-') {
    addSymbolTo(Number);
  }
  while (isdigit(Symbol)) {
    addSymbolTo(Number);
  }
  if (Symbol == '.') {
    addSymbolTo(Number);
    while (isdigit(Symbol)) {
      addSymbolTo(Number);
    }
  }
  if (Symbol == 'e' || Symbol == 'E') {
    addSymbolTo(Number);
    if (Symbol == '-' || Symbol == '+') {
      addSymbolTo(Number);
    }
    while (isdigit(Symbol)) {
      addSymbolTo(Number);
    }    
  }
  return Number;    
}

// Recognize but do not parse nested Objects
string parse_NestedObject(void) {
  string Object = "";
  
  if (Symbol == '{') {
    addSymbolTo(Object);
  }
  while (Symbol != '}') {
    addSymbolTo(Object);
  }
  // IF is redundant?
  if (Symbol == '}') {
    addSymbolTo(Object);
  }
  return Object;
}

// Recognize but do not parse nested Arrays
string parse_NestedArray(void) {
  string Array = "";
  
  if (Symbol == '[') {
    addSymbolTo(Array);
  }
  while (Symbol != ']') {
    addSymbolTo(Array);
  }
  // IF is redundant?
  if (Symbol == ']') {
    addSymbolTo(Array);
  }
  return Array;
  
}

// Decide what Value is
string parse_Value(void) {
  int i;
  string Value = "";
    
  if (Symbol == '"') {
    Value = parse_String();
  } else if (isdigit(Symbol) || Symbol == '-') {
    Value = parse_Number();
  } else if (Symbol == '{') {
    Value = parse_NestedObject();
  } else if (Symbol == '[') {
    Value = parse_NestedArray();
  } else if (Symbol == 't') {
    // true: eat 't' plus three more chars
    for(i=0; i<4; i++){
      updateSymbol();
    }
    Value = "true";    
  } else if (Symbol == 'f') {
    // false: eat 'f' plus four more chars
    for(i=0; i<5; i++){
      updateSymbol();
    }
    Value = "false";
  } else if (Symbol == 'n') {
    // null: eat 'n' plus three more chars
    for(i=0; i<4; i++){
      updateSymbol();
    }
    Value = "null";
  } else {
    // eat any alnum characters
    parse_Chars();
    Value = "undefined";
  }
  return Value;
}

// Get Key & Value
void parse_Pair(dict &Dict) {
  string Key, Value;
  eatWhitespace();
  Key = parse_String();
  eatWhitespace();
  if (Symbol == ':') {
    updateSymbol();
    eatWhitespace();
    Value = parse_Value();
  } else {
    Value = "";
  }
  insert(Key, Value, Node, Dict);
}

// Find all Members in an Object
void parse_Members(dict &Dict) {
  while(1) {
    parse_Pair(Dict);
    eatWhitespace();
    if (Symbol == ',') {
      updateSymbol();
      eatWhitespace();
    } else {
      break;
    }
  }
}

// Find all Elements in an Array
void parse_Elements(dict &Dict) {
  string Key, Value;
  
  while(1) {
    Key = NumToStr(ArrayPtr);
    ArrayPtr++;
    eatWhitespace();
    Value = parse_Value();
    insert(Key, Value, Node, Dict);
    eatWhitespace();

    if (Symbol == ',') {
      updateSymbol();
      eatWhitespace();
    } else {
      break;
    }
  }
}

bool parse_Array(dict &Dict) {
  
  updateSymbol();
  parse_Elements(Dict);
  return (Symbol == ']');
}

bool parse_Object(dict &Dict) {
  
  updateSymbol();
  parse_Members(Dict);
  return (Symbol == '}');
}

bool parse_Text(dict &Dict) {
  bool Status;
  // decide between object or array
  eatWhitespace();
  if (Symbol == '{') {
    Status = parse_Object(Dict);
  } else if (Symbol == '[') {
    Status = parse_Array(Dict);
  } else {
    Status = false;
  }
  return Status;
}

// Return value is "false" only if Buffer is unparseable
bool parse_Json(string &Buffer, string Name, dict &Dict) {
  // Reset state variables
  SymbolPtr = 0;
  ParseBuffer = "";
  ArrayPtr = 0;

  // Start conditions
  ParseBuffer = Buffer;
  Node = Name;

  updateSymbol();

  return parse_Text(Dict);
}
