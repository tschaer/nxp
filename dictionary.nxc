// dictionary.nxc
// 11.01.2012 T. Schaer
// Dictionary
// With function instances
// Note:
// 1. Multidimensional arrays are built using single-dimensional arrays,
//    offset constants, and access functions.
// 2. Multiple instances of the dictionary API are made using macros

// Function definition is a 3-step process:
// 1. Define a macro for a function's internal name. This allows it to be
//    referred to inside other functions of the API
// 2. Define a macro which contains the function's textual representation along
//    with a configurable prefix
// 3. Supply a prefix to the above macro to produce an instance of the function
//    with a unique name in the symbol table

// ***** Dictionary Data Structure Definition
// struct Entry {
//  Key: byte[10]
//  Value: byte[10]
// }
#define KEYLENGTH 10
#define VALUELENGTH 10
#define KEYOFFSET 0
#define VALUEOFFSET KEYLENGTH
#define ENTRYSIZE KEYLENGTH+VALUELENGTH

// struct Node {
//  Entry: Entry[5]
//  Name: byte[10]
//  NextFreeEntry: byte
// }
#define ENTRYPERNODE 5
#define NODENAMELENGTH 10
#define NEXTENTRY 1
#define NODESIZE ENTRYPERNODE*ENTRYSIZE+NODENAMELENGTH+NEXTENTRY
#define NODENAMEOFFSET ENTRYPERNODE*ENTRYSIZE
#define NEXTENTRYOFFSET NODENAMEOFFSET+NODENAMELENGTH

// struct Dict {
//  Node: Node[2]
//  NextFreeNode: byte
// }
#define NODEPERDICT 2
#define NEXTNODE 1
#define DICTSIZE NODEPERDICT*NODESIZE+NEXTNODE
#define NEXTNODEOFFSET NODEPERDICT*NODESIZE

// a cheat to be able to pass byte arrays by reference
typedef string dict;

// *****  Dictionary API

// ----- Byte Array access functions (Optimized)

#define getArraySubset(Offset, Length, ByteArray) asm { arrsubset __STRRETVAL__, ByteArray, Offset, Length }
#define setArraySubset(Offset, Subset, ByteArray) asm { replace ByteArray, ByteArray, Offset, Subset }
#define getArraySingle(Offset, ByteArray) asm { index __RETVAL__, ByteArray, Offset }
#define setArraySingle(Offset, Single, ByteArray) asm { replace ByteArray, ByteArray, Offset, Single }

// ----- Pascal Style Strings
// "pascalized read"
inline string readString(unsigned int Offset, string &ByteArray) {
  byte Length;

  Length = getArraySingle(Offset,ByteArray);
  Offset++;
  return getArraySubset(Offset, Length, ByteArray);
}

// "pascalized write"
// +1 to store the trailing zero
inline void writeString(string String, unsigned int Offset, string &ByteArray) {
  byte Length;
  
  Length = StrLen(String) + 1;
  setArraySingle(Offset, Length, ByteArray);
  Offset++;
  setArraySubset(Offset, String, ByteArray);
}

// ----- Data Structure Access Functions
// Offset calculations
#define getNameOffset(n) n * NODESIZE + NODENAMEOFFSET
#define getFreeEntryOffset(n) n * NODESIZE + NEXTENTRYOFFSET
#define getKeyOffset(n, m) n * NODESIZE + m * ENTRYSIZE + KEYOFFSET
#define getValueOffset(n, m) n * NODESIZE + m * ENTRYSIZE + VALUEOFFSET

#define getNextFreeNode(Arr) getArraySingle(NEXTNODEOFFSET, Arr)
#define setNextFreeNode(x, Arr) setArraySingle(NEXTNODEOFFSET, x, Arr)

inline string getName(byte n, dict &Dict) {
  unsigned int Offset;
  Offset = getNameOffset(n);
  return readString(Offset, Dict);
}

inline void setName(byte n, string Name, dict &Dict) {
  unsigned int Offset;
  Offset = getNameOffset(n);
  writeString(Name, Offset, Dict);
}

inline byte getNextFreeEntry(byte n, dict &Dict) {
  unsigned int Offset;
  Offset = getFreeEntryOffset(n);
  return getArraySingle(Offset, Dict);
}

inline void setNextFreeEntry(byte n, byte Value, dict &Dict) {
  unsigned int Offset;
  Offset = getFreeEntryOffset(n);
  setArraySingle(Offset, Value, Dict);
}

inline string getKey(byte n, byte m, dict &Dict) {
  unsigned int Offset;
  Offset = getKeyOffset(n, m);
  return readString(Offset, Dict);
}

inline void setKey(byte n, byte m, string Key, dict &Dict) {
  unsigned int Offset;
  Offset = getKeyOffset(n, m);
  writeString(Key, Offset, Dict);
}

inline string getValue(byte n, byte m, dict &Dict) {
  unsigned int Offset;
  Offset = getValueOffset(n, m);
  return readString(Offset, Dict);
}

inline void setValue(byte n, byte m, string Value, dict &Dict) {
  unsigned int Offset;
  Offset = getValueOffset(n, m);
  writeString(Value, Offset, Dict);
}

// ----- Helper Functions

#define truncKey(K) SubStr(K, 0, KEYLENGTH-1)
#define truncValue(V) SubStr(V, 0, VALUELENGTH-1)
#define truncNode(N) SubStr(N, 0, NODENAMELENGTH-1)

#define __addEntry(n) n##_addEntry
#define NewAddEntry(n) void __addEntry(n)(byte Node, string Key, string Value, dict &Dict) {\
  byte Entry;\
  Entry = getNextFreeEntry(Node, Dict);\
  setKey(Node, Entry, Key, Dict);\
  setValue(Node, Entry, Value, Dict);\
  Entry++;\
  setNextFreeEntry(Node, Entry, Dict);\
}

#define __addNode(n) n##_addNode
#define NewAddNode(n) void __addNode(n)(string Name, dict &Dict) {\
  byte NextFreeNode;\
  NextFreeNode = getNextFreeNode(Dict);\
  setName(NextFreeNode, Name, Dict);\
  NextFreeNode++;\
  setNextFreeNode(NextFreeNode,Dict);\
}

#define __exists(n) n##_exists
#define NewExists(n) bool __exists(n)(string Name, byte &CurrentNode, dict &Dict) {\
  byte NumberOfNodes;\
  string TempName;\
  bool NodeExists = false;\
  \
  NumberOfNodes = getNextFreeNode(Dict);\
  \
  for(CurrentNode = 0; CurrentNode < NumberOfNodes; CurrentNode++) {\
    TempName = getName(CurrentNode, Dict);\
    if(TempName == Name) {\
      NodeExists = true;\
      break;\
    }\
  }\
  return NodeExists;\
}

#define __lookupKey(n) n##_lookupKey
#define NewLookupKey(n) string __lookupKey(n)(byte CurrentNode, string Key, dict &Dict) {\
  byte NumberOfEntries, CurrentEntry;\
  string TempKey;\
  string Value = "";\
  \
  NumberOfEntries = getNextFreeEntry(CurrentNode, Dict);\
  \
  for(CurrentEntry = 0; CurrentEntry < NumberOfEntries; CurrentEntry++) {\
    TempKey = getKey(CurrentNode, CurrentEntry, Dict);\
    if(TempKey == Key) {\
      Value = getValue(CurrentNode, CurrentEntry, Dict);\
      break;\
    }\
  }\
  return Value;\
}

#define __resetAll(n) n##_resetAll
#define NewResetAll(n) void __resetAll(n)(dict &Dict) {\
  byte Node;\
  \
  setNextFreeNode(0,Dict);\
  for (Node = 0; Node < NODEPERDICT; Node++) {\
    setNextFreeEntry(Node, 0, Dict);\
  }\
}

// ----- Helper Functions API Constructor
#define NewHelperFunctionApi(__n) \
  NewAddEntry(__n);\
  NewAddNode(__n);\
  NewExists(__n);\
  NewLookupKey(__n);\
  NewResetAll(__n);

// ----- Dictionary API

#define __insert(n) n##_insert
#define NewInsert(n) bool __insert(n)(string _Key, string _Value, string _Node, dict &Dict) {\
  byte CurrentNode;\
  string Key, Value, Node;\
  bool NodeExists;\
  \
  Key = truncKey(_Key);\
  Value = truncValue(_Value);\
  Node = truncNode(_Node);\
  \
  NodeExists = __exists(n)(Node, CurrentNode, Dict);\
  \
  if(NodeExists == false) {\
    CurrentNode = getNextFreeNode(Dict);\
    __addNode(n)(Node, Dict);\
  }\
  __addEntry(n)(CurrentNode, Key, Value, Dict);\
  \
  return true;\
}

#define __lookup(n) n##_lookup
#define NewLookup(n) string __lookup(n)(string _Key, string _Node, dict &Dict) {\
  byte CurrentNode = 0;\
  bool NodeExists;\
  string Value = "", Key, Node;\
  \
  Key = truncKey(_Key);\
  Node = truncNode(_Node);\
  \
  NodeExists = __exists(n)(Node, CurrentNode, Dict);\
  \
  if (NodeExists == true) {\
    Value = __lookupKey(n)(CurrentNode, Key, Dict);\
  }\
  return Value;\
}

// ----- Dictionary API Constructor
#define NewDictionaryApi(__n) \
  NewInsert(__n);\
  NewLookup(__n);

// ***** Constructor for the whole API
#define NewDictApi(__n) \
  NewHelperFunctionApi(__n);\
  NewDictionaryApi(__n);

// ***** Temporary location for instantiation

// Instance for Program()
NewDictApi(MainTask);
// Process Dictionary public interface
#define get(Key, Node) MainTask_lookup(Key, Node, ProgramPDI)
#define put(Key, Value, Node) MainTask_insert(Key, Value, Node, ProgramPDO)

// Instance for Comm()
NewDictApi(CommTask);
// These are just lazy cheats to get it working
#define lookup CommTask##_lookup
#define insert CommTask##_insert
#define resetAll CommTask##_resetAll
#define exists CommTask##_exists
